## 学习笔记

### 本周学习了Hash表，树，二叉树，二叉搜索树，堆，二叉堆，图

### 关于HashMap的总结
HashMap最早出现在JDK1.2中，底层基于散列算法实现。HashMap 允许 null 键和 null 值，是非线程安全类，在多线程环境下可能会存在问题。

key通过hash算法计算数据在hash桶中的位置，每个桶里存放的是链表，每个节点对应一个value
JDK1.8中配合红黑树，当链表长度到达8以后，转化成红黑树

在HashMap的构造中`new HashMap();` 完成后，如果没有put操作，是不会分配存储空间的。

HashMap内存数据存储是自己实现了一个链表的结构，通过实现`Map.Entry`而来，还有一个自实现的红黑树结构，来自于`LinkedHashMap.Entry`

- 添加，更新元素
  1. 当桶数组 table 为空时，通过扩容的方式初始化 table
  2. 查找要插入的键值对是否已经存在，如果是hash冲突则在链表后追加元素，如果不是hash冲突则替换元素，根据链表长度决定是否要树化
  3. 判断键值对数量是否超过阈值，大于的话需要调用`resize()`
- 查找元素
  1. 通过`(n - 1) & hash`判断key是否存在，不存在返回`null`
  2. 如果key存在，找到对应的桶的位置，判断首个元素是否满足要求，通过`hash`计算和字面值的`equals`对比，如果满足直接返回
  3. 如果上述无法满足，就表示有`hash`冲突，根据是链表还是红黑树决定获取元素的方式
- 扩容机制
  1. 由于一开始创建HashMap的时候并没有初始化存储空间，所以首次调用`put()`方法的时候会进行一次调用`resize()`
  2. 之后的每一次调用`put()`都会检查size是否大于阈值，如果大于将进行一次`resize()`调用
- loadFactor 负载因子
  1. loadFactor作为一个构造参数，建议使用默认值，值的大小决定HashMap的`resize()`的调用频率
  2. 当我们调低负载因子时，HashMap 所能容纳的键值对数量变少。扩容时，重新将键值对存储新的桶数组里，key之间产生的碰撞会下降，链表长度变短。此时，HashMap 的增删改查等操作的效率将会变高，这里是典型的拿空间换时间。相反，如果增加负载因子（负载因子可以大于1），HashMap 所能容纳的键值对数量变多，空间利用率高，但碰撞率也高。这意味着链表长度变长，效率也随之降低，这种情况是拿时间换空间。至于负载因子怎么调节，这个看使用场景了。
  3. 一般情况下，我们用默认值就可以了。大多数情况下0.75在时间跟空间代价上达到了平衡所以不建议修改。

### 树，二叉树，二叉搜索树

- 树
链表是特殊的树，树是特殊的图
树其实和链表很像，链表通过next指针访问下一个元素，树通过指向子节点的指针访问元素
不过树是一个二维的数据结构，由边和节点共同组成，每条边都连接了两个节点，两个节点间是父子关系，最顶点的节点叫根节点，他的父亲节点为null，一次往下是第一层，第二层，最后一层叶子节点的子节点为null
- 二叉树
每个节点最多有两个子节点，分别为左子节点和右子节点，二叉树通过left，right访问子节点
访问方式分成，前序，中序，后序
- 二叉搜索树
左子树上所有节点的值均小于根节点的值
右子树上所有节点的值均大于根节点的值
左子树和右子树也分别为二叉查找树
二叉搜索树的中序遍历为升序排列
二叉搜索树的查询、插入、删除操作的时间复杂度是O(log n)

### 堆，二叉堆
常见的堆结构有二叉堆，斐波那契堆

二叉堆的数据存储结构为数组
二叉堆的实现其实是一颗完全二叉树，大顶堆跟节点的值最大，任意节点的值大于等于子节点的值，如果是小顶堆，跟节点最小，任意节点小于等于子节点的值

- 二叉堆实现最为简单，但是不推荐工程使用，因为效率不高
  - 删除最大最小元素时间复杂度是O(logn)
  - 查找最大最小元素的时间复杂度是O(1)
  - 插入元素时间复杂度是O(logn)

### 图
包括有权有向图，有权无向图，有向无权图，无向无权图
图是由点和边表示的一种数据结构
有权表示每条边有具体权重也就是具体数字
有向就是表示每条边都有指定的方向，不能随意走向
数据算法表述有深度优先搜索，广度优先搜索
数据表示有邻接表，邻接矩阵
图的高级算法有最小生成树，拓扑排序，连通图个数，最短路径算法