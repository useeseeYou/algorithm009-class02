# 学习笔记

## 高级动态规划

1. 递归，分治，动态规划复习

- `递归`函数调用自身
- `分治`分而治之，使用递归实现
- `动态规划` 找出重复子问题，具有最优子结构，通常使用顺推的形式进行动态递推
- `共性`重复子问题
- `区别`最优子结构，剪枝，中途淘汰次优解

2. 进阶版动态规划

- 动态规划问题的复杂度来源是状态定义和状态转移方程。
  - 状态拥有多个纬度，二维，三维，更多纬度需要状态压缩
  - 状态转移方程更复杂
- 感触
  - 人肉递归低效，很累
  - 找到最近最简方法，将其拆解成可重复解决的子问题
  - 数学归纳法思维很重要

## 字符串算法

### 字符串基础

字符串在java，python中是不可变的

### 字符串匹配算法

字符串匹配算法用于匹配模式在字符串中第一次出现的位置，其中字符串的长度是m，模式串的长度是n，满足m > n。

暴力解法时间复杂度是O(mn)。

Rabin-Karp算法基于`hash`的，平均时间复杂度是O(m+n)。

Knuth-Morris-Pratt算法利用最大前缀信息，类似布隆过滤器添加了缓存区，减少不必要的比较次数，时间复杂度是O(m+n)。

## `不同路径II` 的状态转移方程

状态表示：穿件包含m行和n列的二维数组`dp`，其中`dp[i][j]`表示从左上角到位置`(i,j)`的不同路径数。

边界：优于美不只能下走或者右走，所以`dp`的第一行和第一列的只为1或者0，从左到右遍历第一行，如果没有障碍物，则对应的`dp`值为1，一旦遇到障碍物，则第一行从这个位置开始向右的全部元素对应的`dp`值都为0。从上到下遍历第一列，如果没有障碍物，则对应的`dp`值为1，如果有障碍物则第一列从这个位置开始向下全部元素的`dp`值都为0。

状态转移方程：当`i > 0`且`j > 0`时，首先判断位置`(i,j)`是否为障碍物，如果是障碍物则`dp[i][j] = 0`，如果不是障碍物则位置`(i,j)`可由位置`(i - 1,j)`下移一步到达或者由位置`(i,j - 1)`右移一步到达，因此`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`。

因此状态转移方程分解为如下两种情况，只适合于`i > 0`且`j > 0`的情况。

- 如果`grid[i][j] == 1`，则`dp[i][j] = 0`。
- 如果`grid[i][j] == 0`，则`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`。

遍历整个网格之后，`dp[m - 1][n - 1]`即为不同路径数。