# 学习笔记


## 位运算

机器里的数字表示方式和存储格式就是二进制

位运算操作符：左移(<<)，右移(>>)，按位或(|)，按位与(&)，按位取反(~)，按位异或(^)

## 布隆过滤器

布隆过滤器使用场景为判断数据是否存在，可对缓存起到一个增强防护的作用，本身占用空间也非常小

优点：空间复杂度，时间复杂度都优于其他数据结构，但是是牺牲了正确率的
缺点：基于概率做数据查询，对数据误判，如果查询数据不存在就一定不存在，如果查询存在则还无法确定真的存在

## LRU缓存

查询，修改，删除时间复杂度O(1)
使用双向链表，哈希表实现

## 排序算法

### 基本排序算法分类

粗略分类排序可以分为比较类和非比较类
1.比较类排序通过比较决定元素的次序，时间复杂度无法突破O(nlogn)，也叫非线性时间比较类排序

比较类排序有：交换排序(冒泡排序，快速排序)，插入排序(简单插入排序，希尔排序)，选择排序(简单选择排序，堆排序)，归并排序(二路归并排序，多路归并排序)

2.非比较类排序不通过比较决定元素次序，可以突破基于比较排序的时间下界，以线性时间运行，因此也叫线性时间非比较类排序

非比较类排序有：基数排序，计数排序，桶排序

### 初级排序 - O(n^2)

1.选择排序

每次找最小值，然后放到待排序数组的起始位置

2.插入排序

从前到后逐步构建有序序列l；对于未排序数据，在已排序序列中从后向前扫描，找到对应位置插入

3.冒泡排序

嵌套循环，每次比较相邻的元素如果逆序就交换

### 高级排序 - O(N*LogN)

1.快速排序

数组取标杆pivot，将小元素放在pivot的左侧，大元素放右侧，然后依次对右边和右边的子数组继续快排，以达到整个序列有序

2.归并排序（merge sort）--- 分治思想

- 把长度为n的输入序列分成两个长度为n/2的子序列
- 对这两个子序列分别采用归并排序
- 将两个排序好的子序列合并成一个最终有序的序列

归并 和 快排 具有相似性，但步骤顺序相反

归并：先排序左右子数组，然后合并两个有序子数组

快排：先调配出左右子数组，然后对于左右子数组进行排序

3.堆排序（Heap sort）--- 堆插入O(logN)，取最大/小值O(1)

- 数组元素依次建立小顶堆
- 依次取堆顶元素，并删除

### 特殊排序 - O(n)

1.计数排序（Counting Sort） 

计数排序要求输入的数据必须是有确定范围的整数。将输入的数据值转化为键存储在额外开辟的数组空间中；然后依次把计数大于 1 的填充回原数组

2.桶排序（Bucket Sort） 

桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）

3.基数排序（Radix Sort） 

基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。

## 实现初级排序代码

- 冒泡排序

``` java
public void bubbleSort(int[] nums) {
    int len = nums.length;
    for (int i = 0; i < len; i++) {
        for (int j = 1; j < len; j++) {
            if (nums[i] > nums[j]) {
                int temp = nums[j];
                nums[j] = nums[i];
                nums[i] = temp;
            }
        }
    }
}
```

- 选择排序

``` java
public void selectionSort(int[] nums) {
    int len = nums.length;
    for (int i = 0; i < length - 1; i++) {
        int curMin = nums[i];
        int curMinIndex = i;
        for (int j = i + 1; j < length; j++) {
            if (curMin > nums[i]) {
                curMin = nums[i];
                curMinIndex = j;
            }
        }
        if (curMinIndex != i) {
            nums[curMinIndex] = nums[i];
            nums[i] = curMin;
        }
    }
}
```

- 插入排序

``` java
public void insertionSort(int[] nums) {
    int len = nums.length;
    for (int i = 1; i < length; i++) {
        int num = nums[i];
        int insertionIndex = 0;
        for (int j = i - 1; j >= 0; --j) {
            if (nums[j] > num) {
                nums[j + 1] = nums[j];
            } else {
                insertionIndex = j + 1;
                break;
            }
        }
        nums[insertionIndex] = num;
    }
}
```

